


# lerpTo method







- @[override](https://api.flutter.dev/flutter/dart-core/override-constant.html)

ShapeBorder lerpTo
(ShapeBorder b, [double](https://api.flutter.dev/flutter/dart-core/double-class.html) t)

_inherited_



<p>Linearly interpolates from <code>this</code> to another <code>ShapeBorder</code> (possibly of
another class).</p>
<p>This is called if <code>b</code>'s <a href="../../ui_ring_border/RingBorder/lerpTo.md">lerpTo</a> did not know how to handle this class.</p>
<p>When implementing this method in subclasses, return null if this class
cannot interpolate from <code>b</code>. In that case, <code>lerp</code> will apply a default
behavior instead. If <code>b</code> is null, this must not return null.</p>
<p>The base class implementation handles the case of <code>b</code> being null by
deferring to <a href="../../ui_ring_border/RingBorder/scale.md">scale</a>.</p>
<p>The <code>t</code> argument represents position on the timeline, with 0.0 meaning
that the interpolation has not started, returning <code>this</code> (or something
equivalent to <code>this</code>), 1.0 meaning that the interpolation has finished,
returning <code>b</code> (or something equivalent to <code>b</code>), and values in between
meaning that the interpolation is at the relevant point on the timeline
between <code>this</code> and <code>b</code>. The interpolation can be extrapolated beyond 0.0
and 1.0, so negative values and values greater than 1.0 are valid (and can
easily be generated by curves such as <code>Curves.elasticInOut</code>).</p>
<p>Values for <code>t</code> are usually obtained from an <code>Animation&lt;double&gt;</code>, such as
an <code>AnimationController</code>.</p>
<p>Instead of calling this directly, use <code>ShapeBorder.lerp</code>.</p>



## Implementation

```dart
@override
ShapeBorder? lerpTo(ShapeBorder? b, double t) {
  if (b is CircleBorder)
    return CircleBorder(side: BorderSide.lerp(side, b.side, t));
  return super.lerpTo(b, t);
}
```







