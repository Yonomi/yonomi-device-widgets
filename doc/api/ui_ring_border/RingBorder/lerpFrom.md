


# lerpFrom method







- @[override](https://api.flutter.dev/flutter/dart-core/override-constant.html)

ShapeBorder lerpFrom
(ShapeBorder a, [double](https://api.flutter.dev/flutter/dart-core/double-class.html) t)

_inherited_



<p>Linearly interpolates from another <code>ShapeBorder</code> (possibly of another
class) to <code>this</code>.</p>
<p>When implementing this method in subclasses, return null if this class
cannot interpolate from <code>a</code>. In that case, <code>lerp</code> will try <code>a</code>'s <a href="../../ui_ring_border/RingBorder/lerpTo.md">lerpTo</a>
method instead. If <code>a</code> is null, this must not return null.</p>
<p>The base class implementation handles the case of <code>a</code> being null by
deferring to <a href="../../ui_ring_border/RingBorder/scale.md">scale</a>.</p>
<p>The <code>t</code> argument represents position on the timeline, with 0.0 meaning
that the interpolation has not started, returning <code>a</code> (or something
equivalent to <code>a</code>), 1.0 meaning that the interpolation has finished,
returning <code>this</code> (or something equivalent to <code>this</code>), and values in
between meaning that the interpolation is at the relevant point on the
timeline between <code>a</code> and <code>this</code>. The interpolation can be extrapolated
beyond 0.0 and 1.0, so negative values and values greater than 1.0 are
valid (and can easily be generated by curves such as
<code>Curves.elasticInOut</code>).</p>
<p>Values for <code>t</code> are usually obtained from an <code>Animation&lt;double&gt;</code>, such as
an <code>AnimationController</code>.</p>
<p>Instead of calling this directly, use <code>ShapeBorder.lerp</code>.</p>



## Implementation

```dart
@override
ShapeBorder? lerpFrom(ShapeBorder? a, double t) {
  if (a is CircleBorder)
    return CircleBorder(side: BorderSide.lerp(a.side, side, t));
  return super.lerpFrom(a, t);
}
```







